import * as tslib_1 from "tslib";
import { Input, Directive, forwardRef } from '@angular/core';
import { NG_ASYNC_VALIDATORS } from '@angular/forms';
import { of } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
var AsyncValidationDirective = /** @class */ (function () {
    function AsyncValidationDirective() {
    }
    AsyncValidationDirective_1 = AsyncValidationDirective;
    AsyncValidationDirective.prototype.validate = function (control) {
        if (this.async)
            return this.async(control);
        return of(null);
    };
    var AsyncValidationDirective_1;
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], AsyncValidationDirective.prototype, "async", void 0);
AsyncValidationDirective.ɵfac = function AsyncValidationDirective_Factory(t) { return new (t || AsyncValidationDirective)(); };
AsyncValidationDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AsyncValidationDirective, selectors: [["", "ngModel", ""], ["", "formControlName", ""], ["", "formControl", ""]], inputs: { async: "async" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_ASYNC_VALIDATORS,
                useExisting: forwardRef(function () { return AsyncValidationDirective_1; }),
                multi: true
            }])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AsyncValidationDirective, [{
        type: Directive,
        args: [{
                selector: '[ngModel],[formControlName],[formControl]',
                providers: [{
                        provide: NG_ASYNC_VALIDATORS,
                        useExisting: forwardRef(function () { return AsyncValidationDirective_1; }),
                        multi: true
                    }]
            }]
    }], function () { return []; }, { async: [{
            type: Input
        }] }); })();
    return AsyncValidationDirective;
}());
export { AsyncValidationDirective };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXN5bmMtdmFsaWRhdGlvbi5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIkByeHdlYi9yZWFjdGl2ZS1mb3JtLXZhbGlkYXRvcnMvZGlyZWN0aXZlcy90ZW1wbGF0ZS12YWxpZGF0aW9ucy9hc3luYy12YWxpZGF0aW9uLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFjLE1BQU0sZUFBZSxDQUFDO0FBQ3pFLE9BQU8sRUFBcUMsbUJBQW1CLEVBQW9DLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUgsT0FBTyxFQUFjLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQzs7QUFTdEM7QUFBNEQsSUFBNUQ7QUFBc0MsSUFRdEMsQ0FBQztBQUNELGlDQVRhLHdCQUF3QjtBQUFFLElBR25DLDJDQUFRLEdBQVIsVUFBUyxPQUF3QjtBQUFJLFFBQ2pDLElBQUksSUFBSSxDQUFDLEtBQUs7QUFDdEIsWUFBWSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDdkMsUUFBUSxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN4QixJQUFJLENBQUM7QUFDSjtBQUNrQyxJQVJ0QjtBQUVMLFFBRkgsS0FBSyxFQUFFO0FBQUU7QUFFd0IsMkRBRmQ7SUFEWCx3QkFBd0IsNkRBUnBDLFNBQVMsQ0FBQyxjQUNQLFFBQVEsRUFBRTtzQ0FBMkMsY0FDckQsU0FBUyxFQUFFLENBQUMsc0JBQ1IsT0FBTyxFQUFFLG1CQUFtQixzQkFDNUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxjQUFNLE9BQUEsMEJBQXdCLEVBQXhCLENBQXdCLENBQUMsc0JBQ3ZELEtBQUssRUFBRSxJQUFJO2VBQ2QsQ0FBQyxVQUNMLENBQUMsUUFDVzthQUF3QixDQVFwQzs7Ozs7Ozs7Ozs7Ozs7O29CQUNEO0FBQUMsSUFERCwrQkFBQztBQUNBLENBREEsQUFSRCxJQVFDOztBQW5CQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQVNBLEFBQUEsQUFRQSxBQUFBLEFBUkEsQUFBQSxBQUdBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBTkEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQURBLEFBQUEsQUFSQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFRQSxBQUFBLEFBQUEsQUFBQSxBQVJBLEFBUUEsQUFSQSxBQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5wdXQsIERpcmVjdGl2ZSwgZm9yd2FyZFJlZiwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3JzLCBBYnN0cmFjdENvbnRyb2wsIE5HX0FTWU5DX1ZBTElEQVRPUlMsIEFzeW5jVmFsaWRhdG9yLCBBc3luY1ZhbGlkYXRvckZuIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAnW25nTW9kZWxdLFtmb3JtQ29udHJvbE5hbWVdLFtmb3JtQ29udHJvbF0nLFxyXG4gICAgcHJvdmlkZXJzOiBbe1xyXG4gICAgICAgIHByb3ZpZGU6IE5HX0FTWU5DX1ZBTElEQVRPUlMsXHJcbiAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQXN5bmNWYWxpZGF0aW9uRGlyZWN0aXZlKSxcclxuICAgICAgICBtdWx0aTogdHJ1ZVxyXG4gICAgfV1cclxufSlcclxuZXhwb3J0IGNsYXNzIEFzeW5jVmFsaWRhdGlvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIEFzeW5jVmFsaWRhdG9yIHtcclxuICAgIEBJbnB1dCgpIGFzeW5jOiBhbnk7XHJcblxyXG4gICAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogUHJvbWlzZTxWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbD4gfCBPYnNlcnZhYmxlPFZhbGlkYXRpb25FcnJvcnMgfCBudWxsPiB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXN5bmMpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzeW5jKGNvbnRyb2wpO1xyXG4gICAgICAgIHJldHVybiBvZihudWxsKTtcclxuICAgIH1cclxufVxyXG4iXX0=